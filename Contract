// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract TimeLockVault is ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Lock {
        address owner;
        address token; // address(0) for ETH
        uint256 amount;
        uint256 unlockTime;
        bool withdrawn;
    }

    uint256 public nextLockId;
    mapping(uint256 => Lock) public locks;
    mapping(address => uint256[]) public ownerLocks;

    event Locked(uint256 indexed lockId, address indexed owner, address indexed token, uint256 amount, uint256 unlockTime);
    event Withdrawn(uint256 indexed lockId, address indexed owner, address indexed token, uint256 amount);

    function depositETH(uint256 unlockTime) external payable returns (uint256 lockId) {
        require(msg.value > 0, "No ETH sent");
        require(unlockTime > block.timestamp, "unlockTime in past");

        lockId = nextLockId++;
        locks[lockId] = Lock(msg.sender, address(0), msg.value, unlockTime, false);
        ownerLocks[msg.sender].push(lockId);

        emit Locked(lockId, msg.sender, address(0), msg.value, unlockTime);
    }

    function depositERC20(IERC20 token, uint256 amount, uint256 unlockTime) external returns (uint256 lockId) {
        require(amount > 0, "amount 0");
        require(unlockTime > block.timestamp, "unlockTime in past");

        token.safeTransferFrom(msg.sender, address(this), amount);

        lockId = nextLockId++;
        locks[lockId] = Lock(msg.sender, address(token), amount, unlockTime, false);
        ownerLocks[msg.sender].push(lockId);

        emit Locked(lockId, msg.sender, address(token), amount, unlockTime);
    }

    function withdraw(uint256 lockId) external nonReentrant {
        Lock storage l = locks[lockId];
        require(l.owner == msg.sender, "Not owner");
        require(!l.withdrawn, "Already withdrawn");
        require(block.timestamp >= l.unlockTime, "Locked");

        l.withdrawn = true;
        if (l.token == address(0)) {
            uint256 amt = l.amount;
            (bool sent, ) = msg.sender.call{value: amt}("");
            require(sent, "ETH transfer failed");
            emit Withdrawn(lockId, msg.sender, address(0), amt);
        } else {
            IERC20(l.token).safeTransfer(msg.sender, l.amount);
            emit Withdrawn(lockId, msg.sender, l.token, l.amount);
        }
    }

    function getLocksOf(address user) external view returns (uint256[] memory) {
        return ownerLocks[user];
    }
}
